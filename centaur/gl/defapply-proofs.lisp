
(in-package "GL")
(include-book "defapply")
(include-book "tools/defevaluator-fast" :dir :system)
(include-book "clause-processors/unify-subst" :dir :system)
(include-book "clause-processors/meta-extract-user" :dir :system)
(include-book "clause-processors/find-subterms" :dir :system)
(include-book "tools/match-tree" :dir :system)

(defun arity-table-p (atbl)
  (declare (xargs :guard t))
  (if (atom atbl)
      (eq atbl nil)
    (and (consp (car atbl))
         (symbolp (caar atbl))
         (not (eq (caar atbl) 'quote))
         (natp (cdar atbl))
         (arity-table-p (cdr atbl)))))

(defun apply-body-nths-lst (start done)
  (declare (xargs :measure (nfix (- (nfix done) (nfix start)))
                  :guard (and (natp start)
                              (natp done)
                              (<= start done))))
  (if (mbe :logic (zp (- (nfix done)
                         (nfix start)))
           :exec (int= done start))
      nil
    (cons `(nth ',start args)
          (apply-body-nths-lst (+ 1 (lnfix start)) done))))

(defthm not-assoc-quote-when-arity-table-p
  (implies (arity-table-p atbl)
           (not (assoc 'quote atbl))))

(defun apply-body-from-arity-table (atbl default-term)
  (declare (xargs :Guard (arity-table-p atbl)))
  (if (atom atbl)
      default-term
    `(IF (IF (EQ F ',(caar atbl))
            (IF (TRUE-LISTP ARGS)
                (EQL (LEN ARGS) ',(cdar atbl))
                'NIL)
            'NIL)
         ;; ec-call is not applied to functions in acl2::*ec-call-bad-ops*
         ,(if (hide (member-eq (caar atbl) acl2::*ec-call-bad-ops*))
              `(,(caar atbl) . ,(apply-body-nths-lst
                                 0 (cdar atbl)))
            `(RETURN-LAST 'ACL2::EC-CALL1-RAW
                          'NIL
                          (,(caar atbl) . ,(apply-body-nths-lst
                                            0 (cdar atbl)))))
        ,(apply-body-from-arity-table (cdr atbl) default-term))))


;; gets rid of the return-last
(defun apply-body-from-arity-table-simp (atbl default-term)
  (declare (xargs :Guard (arity-table-p atbl)))
  (if (atom atbl)
      default-term
    `(IF (IF (EQ F ',(caar atbl))
            (IF (TRUE-LISTP ARGS)
                (EQL (LEN ARGS) ',(cdar atbl))
                'NIL)
            'NIL)
         ,(if (and (eq (caar atbl) 'implies)
                   (eql (cdar atbl) 2))
              ;; argh, dumb special case because implies gets simplified to ifs
              `(IF (NTH '0 ARGS)
                   (IF (NTH '1 ARGS) 'T 'NIL)
                   'T)
            `(,(caar atbl) . ,(apply-body-nths-lst 0 (cdar atbl))))
         ,(apply-body-from-arity-table-simp (cdr atbl) default-term))))

(local
 (progn
   (defconst *little-apply-fns*
     '(BINARY-*
       BINARY-+
       PKG-WITNESS))

   (make-event `(defapply little-apply ,*little-apply-fns*))

   (make-event
    (let ((body (acl2::meta-extract-formula 'little-apply state))
          (from-atbl `(equal (little-apply f args)
                             ,(apply-body-from-arity-table
                               (little-apply-arities)
                               '(apply-stub f args)))))
      (if (equal body from-atbl)
          '(value-triple :ok)
        (er hard? 'apply-body-from-arity-table
            "It seems the form of apply function bodies has changed?  Body: ~
        ~x0~%As generated by apply-body-from-arity-table: ~x1~%"
            body from-atbl))))))

(acl2::defevaluator-fast
 app-ev app-ev-lst
 ((if a b c)
  (eq a b)
  (true-listp a)
  (eql a b)
  (len a)
  (return-last a b c)
  (apply-stub a b)
  (member-equal a b)
  (cons a b)
  (binary-+ a b)
  (equal a b)
  (not a)
  (iff a b)
  (implies a b)
  (acl2::typespec-check a b)
  (nth a b))
 :namedp t)

(acl2::def-meta-extract app-ev app-ev-lst)
(acl2::def-unify app-ev app-ev-alist)

(local (defthm assoc-equal-consp
         (implies (alistp x)
                  (or (not (assoc-equal k x))
                      (consp (assoc-equal k x))))
         :rule-classes (:type-prescription
                        (:rewrite
                         :corollary (implies (and (alistp x)
                                                  (assoc-equal k x))
                                             (consp (assoc-equal k x)))))))

(defthm app-ev-match-tree-correct
  (b* (((mv ok alist) (acl2::match-tree pat x alist)))
    (implies ok
             (equal (app-ev x a)
                    (app-ev (acl2::subst-tree pat alist) a))))
  :hints(("Goal" :in-theory (enable acl2::match-tree-is-subst-tree))))

(defthm app-ev-disjoin-match-tree-correct
  (b* (((mv ok alist) (acl2::match-tree pat x alist)))
    (implies ok
             (equal (app-ev (disjoin x) a)
                    (app-ev (disjoin (acl2::subst-tree pat alist)) a))))
  :hints(("Goal" :in-theory (enable acl2::match-tree-is-subst-tree))))


(defun match-apply-body (apply-body arities finish)
  (declare (xargs :guard (arity-table-p arities)))
  (equal apply-body (apply-body-from-arity-table arities finish)))

(defthm match-apply-body-correct
  (implies (match-apply-body apply-body arities finish)
           (equal (app-ev apply-body a)
                  (app-ev (apply-body-from-arity-table arities finish) a))))

(in-theory (disable match-apply-body))

(defun match-apply-body-simp (apply-body arities finish)
  (declare (xargs :guard (arity-table-p arities)))
  (equal apply-body (apply-body-from-arity-table-simp arities finish)))

(defthm match-apply-body-simp-correct
  (implies (match-apply-body-simp apply-body arities finish)
           (equal (app-ev apply-body a)
                  (app-ev (apply-body-from-arity-table-simp arities finish) a))))

(in-theory (disable match-apply-body-simp))



(local
 (progn
   (acl2::def-match-tree-rewrites ((:?f arities-fn)))
   (acl2::def-match-tree-rewrites (quote (:? arities)))
   (acl2::def-match-tree-rewrites ((:?f apply-fn) f args))
   (acl2::def-match-tree-rewrites ((EQUAL (IF (IF (MEMBER-EQUAL (CONS F (LEN ARGS))
                                                                (:? arities-call))
                                                  (TRUE-LISTP ARGS)
                                                  'NIL)
                                              (:? apply-call)
                                              (:? assoc-call))
                                          (:? apply-body-with-assoc-call))))))

(defun apply-with-stub/alist-cp (clause hint state)
  (declare (xargs :stobjs state
                  :guard (pseudo-term-listp clause))
           (ignore hint))
  (b* (((acl2::unless-match clause
                            ((EQUAL (IF (IF (MEMBER-EQUAL (CONS F (LEN ARGS))
                                                          (:? arities-call))
                                            (TRUE-LISTP ARGS)
                                            'NIL)
                                        (:? apply-call)
                                        (:? assoc-call))
                                    (:? apply-body-with-assoc-call))))
        (cw "unify failed~%")
        (mv nil (list clause)))
       ((acl2::unless-match arities-call ((:?f arities-fn)))
        (cw "unexpected form of arities-call~%")
        (mv nil (list clause)))
       ((mv ok ar-formals arities-body) (acl2::fn-get-def arities-fn state))
       ((unless (and ok (not ar-formals)))
        (cw "arities definition lookup failed~%")
        (mv nil (list clause)))
       ((acl2::unless-match arities-body (quote (:? arities)))
        (cw "unexpected form of arities body~%")
        (mv nil (list clause)))
       ((unless (arity-table-p arities))
        (cw "bad arities~%")
        (mv nil (list clause)))
       ((unless (match-apply-body-simp
                 apply-body-with-assoc-call
                 arities assoc-call))
        (cw "bad apply-body-with-assoc-call. is: ~x0 should: ~x1~%"
            apply-body-with-assoc-call
            (apply-body-from-arity-table-simp arities assoc-call))
        (mv nil (list clause)))
       ((acl2::unless-match apply-call ((:?f apply-fn) f args))
        (cw "bad apply-call~%")
        (mv nil (list clause)))
       ((mv ok apply-formals apply-body) (acl2::fn-get-def apply-fn state))
       ((unless (and ok (equal apply-formals '(f args))))
        (cw "bad apply definition lookup~%")
        (mv nil (list clause)))
       ((unless (match-apply-body apply-body arities '(apply-stub f args)))
        (cw "bad apply definition. is: ~x0~%should: ~x1~%"
            apply-body
            (apply-body-from-arity-table arities '(apply-stub f args)))
        (mv nil (list clause))))
    (cw "apply-with-stub/alist-cp succeeded~%")
    (mv nil nil)))


(encapsulate nil
  (local (include-book "arithmetic/top-with-meta" :dir :system))
  (local (Defthm nfix-of-natp
           (implies (natp x)
                    (equal (nfix x) x))))
  (local (defthm cons-nth-nthcdr
           (implies (< (nfix n) (len x))
                    (equal (cons (nth n x)
                                 (nthcdr (+ 1 (nfix n)) x))
                           (nthcdr n x)))
           :hints(("Goal" :in-theory (enable nth nthcdr)))))

  (local (defthm nthcdr-too-many
           (implies (and (<= (len x) (nfix n))
                         (true-listp x))
                    (equal (nthcdr n x) nil))))

  (defthm app-ev-lst-of-apply-body-nths-lst
    (implies (and (equal (len (cdr (assoc 'args a))) len)
                  (true-listp (cdr (assoc 'args a))))
             (equal (app-ev-lst (apply-body-nths-lst n len) a)
                    (nthcdr n (cdr (assoc 'args a)))))
    :hints(("Goal" :in-theory (disable nth nthcdr nfix)
            :induct (apply-body-nths-lst n len)))))

(defthm apply-body-from-arity-table-when-member
  (implies (and (arity-table-p ars)
                (member (cons (cdr (assoc 'f a))
                              (len (cdr (assoc 'args a)))) ars)
                (true-listp (cdr (assoc 'args a))))
           (equal (app-ev (apply-body-from-arity-table ars final) a)
                  (app-ev (cons (cdr (assoc 'f a))
                                (kwote-lst (cdr (assoc 'args a))))
                          nil)))
  :hints((and stable-under-simplificationp
              (equal (car id) '(0))
              '(:induct (apply-body-from-arity-table ars final)
                :in-theory (enable app-ev-of-fncall-args)))))

(defthm apply-body-from-arity-table-when-not-ok
  (implies (and (arity-table-p ars)
                (not (and (member (cons (cdr (assoc 'f a))
                                        (len (cdr (assoc 'args a)))) ars)
                          (true-listp (cdr (assoc 'args a))))))
           (equal (app-ev (apply-body-from-arity-table ars final) a)
                  (app-ev final a)))
  :hints(("goal" :induct (apply-body-from-arity-table ars final)
          :in-theory (enable app-ev-of-fncall-args))))

(defthm app-ev-of-apply-body-from-arity-table-simp
  (equal (app-ev (apply-body-from-arity-table-simp arites final) a)
         (app-ev (apply-body-from-arity-table arites final) a)))


(defthm apply-with-stub/alist-cp-correct
  (implies (and (pseudo-term-listp clause)
                (alistp a)
                (app-ev-meta-extract-global-facts)
                (app-ev (conjoin-clauses (acl2::clauses-result
                                          (apply-with-stub/alist-cp
                                           clause hint state)))
                        a))
           (app-ev (disjoin clause) a))
  :hints (("goal" :do-not-induct t
           :in-theory (e/d (app-ev-of-fncall-args)
                           (app-ev-meta-extract-formula))))
  :otf-flg t
  :rule-classes :clause-processor)




(local 
 (progn
   (defthm little-apply-appalist-instance-of-little-apply
     t
     :hints (("goal" :use ((:functional-instance
                            little-apply
                            (little-apply
                             (lambda (f a)
                               (if (and (member-equal (cons f (len a))
                                                      (little-apply-arities))
                                        (true-listp a))
                                   (little-apply f a)
                                 (cdr (assoc (cons f a) alist)))))
                            (apply-stub
                             (lambda (f a) (cdr (assoc (cons f a) alist))))))
              :in-theory nil
              :do-not '(preprocess simplify))
             (and stable-under-simplificationp
                  (not (cw "clause: ~x0~%" clause))
                  '(:clause-processor (apply-with-stub/alist-cp clause nil state))))
     :rule-classes nil)))



